"""Модуль для анализа речи, распознавания команд и маршрутов и объектов.
В этой версии реализовано более точное распознавание имеющихся объектов,
с меньшим количеством ложных срабатываний, что дает возможность пропускать
незнакомые объекты для дальнейшей разборки с помощью ИИ.
В списке объектов теперь можно хранить не только остановки, но и названия других
объектов и улиц.
Теперь, объект имеющийся в списке, будет не распознан, если после него идет цифра.
Это сделано для пропуска адресов, поскольку некоторые остановки имеют названия улиц и
распознаются по этому названию как остановки. Например: Тутаринова. Если будет
Тутаринова 15, такая запись будет пропущена. Соответственно и Дом быта 11 будет пропущена,
но это не должно сказаться на работе программы, поскольку такое название не имеет смысла.

"""

import re
import logging
import jellyfish
from num2words import num2words
from rapidfuzz import process, fuzz

logger = logging.getLogger('alisa')

LIMIT = 83  # Порог, при значении ниже которого новое слово для сущности бракуется
RESOLVE = 95  # Если баллы выше или равны этому значению - сущность признается


def text_preparation(text):
    """Подготовка текста к анализу:
    - переводит в нижний регистр
    - удаляет знаки препинания и др. оставляя только буквы и цифры
    - меняет букву ё на ё
    - меняет числа на слова.
    Возвращает обработанный текст.
    """
    text = text.lower().replace('ё', 'е')
    text = re.sub(r'\W+', ' ', text)

    # Замена в тексте чисел словами
    def replace_match(match):
        number = match.group()
        return num2words(int(number), lang='ru')

    # Заменяем числа в тексте
    return re.sub(r'\b\d+\b', replace_match, text)


def remove_similar_words(word_list: list, delete_list: list, threshold=70) -> list:
    """Удаление из списка слов похожих на слова в списке удаления."""
    filtered_words = []

    for word in word_list:
        match, score, _ = process.extractOne(word_list, delete_list, scorer=fuzz.ratio)
        if score < threshold:  # Если слово недостаточно похоже, оставляем его
            filtered_words.append(word)

    return filtered_words


class Find:
    """Класс для проверки переданной фразы на соответствие списку сущностей.
    Словарь сущностей формируется при инициализации класса."""

    def __init__(self, anything_list: list, add_dict: dict):
        """
        anything_list: Список сущностей, как в БД. Так их нужно возвращать
        add_dict: Словарь, где в ключах сущности для которых есть расширенные
            списки вариантов названий. Эти названия в значениях в списке: {name: [list]}.

        Подготовка словаря из списка и словаря: {name: [list]}.
        Ключи словаря будут названия объектов как в БД,
        А значениями списки альтернативных названий, но:
        в нижнем регистре, ё=е, числа заменены словами, без знаков препинания.
        """
        self.alter_dict = {}
        for word in anything_list:
            new_list = {text_preparation(word)}
            if word in add_dict:
                for item in add_dict[word]:
                    new_list.add(text_preparation(item))
            self.alter_dict[word] = new_list


    def find_matching_entity(self, phrase: str) -> tuple:
        """
        Поиск сущности в переданной фразе.
        Перебирает словарь списков альтернативных названий, сопоставляет с фразой.
        Возвращает лучшее совпадение в виде кортежа:
        (правильное название сущности, какая альтернатива лучшая, процент совпадения)
        """
        entity = ('', '', 0)
        # Перебор всех сущностей в словаре
        for entity_name, alter_list in self.alter_dict.items():
            for alter_name in alter_list:
                score = int(jellyfish.jaro_winkler_similarity(phrase, alter_name) * 100)
                if score >= entity[2]:
                    entity = (entity_name, alter_name, score)
        return entity


def select_samples_by_phrase(phrase: str, anything_list: list, add_dict: dict, threshold: int = 90) -> list:
    """Ищет и возвращает наиболее подходящие встречаемые в переданном тексте шаблонные фразы
    из списка фраз и расширительного словаря. Пример:
    'Найди автобус от социалистической до мясокомбината' -
    в этой фразе должна вернуть ['Социалистическая', 'Мясокомбинат'].
    Возвращает список шаблонных фраз (оригинальных) в порядке встреченном во фразе.
    """
    # Подготовка объекта для сопоставления
    find = Find(anything_list, add_dict)

    # Обработка текста, получение токенов
    phrase = text_preparation(phrase)
    words_start = phrase.split()

    # Удаляем нежелательные слова.
    # Меняем числа на слова
    delete_words = ['алиса', 'номер']
    words = remove_similar_words(words_start, delete_words)
    print(words)
    logger.warning(f"Запрос к Алисе:\n{' '.join(words)}")

    """
    Алгоритм поиска сущностей.
    1. Получаем список слов (фразу) в words
    2. index = 0, указатель на слово во фразе
       count = 1, количество слов в сущности.
       (Это текущая (предполагаемая) сущность выделенная в words)
       
       limit = 50, порог, при значении ниже которого новое слово для сущности бракуется
    3. Цикл пока index + count <= длины фразы words
    4. Сопоставляем текущую сущность со всеми списками альтернативного словаря,
       находим максимальный балл совпадения best, сущность и чем она найдена temp
    5. Если лучший балл (best) меньше порога (limit) то:
       - если limit >= 90 - запоминаем новую сущность entities d out_entities, 
         index = index + count - 1, count = 1
       - если limit < 90 - index = index + 1 (переходим к следующему слову)
       - limit = 50
       - entities = None
       - перейти к п.3
    6. Если лучший балл (best) больше порога (limit) то:
       - limit = best, count = count + 1, entities = temp
       - перейти к п.3
    7. Произошел выход из цикла:
       если есть entities - запоминаем ее в out_entities
    8. Возвращаем сущности out_entities или производим дальнейшую обработку.
    """

    found_entities = []  # Найденные сущности
    pre_entities = None  # Вероятная сущность

    # Это текущая (предполагаемая) сущность выделенная в word
    index = 0  # Указатель на слово во фразе
    count = 1  # Количество слов в сущности

    limit = LIMIT

    while index + count <= len(words):
        # Находим лучшее соответствие среди всех сущностей
        # (правильное название сущности, какая альтернатива лучшая, процент совпадения)
        temp_entity = find.find_matching_entity(' '.join(words[index: index + count]))
        print(f"Для строки |{' '.join(words[index: index + count])}| лучшее совпадение {temp_entity}")
        if temp_entity[2] < limit:
            # Показатель совпадения с новым словом низкий или ухудшился
            if limit >= RESOLVE:
                # Найдена новая сущность
                found_entities.append(pre_entities)
                index = index + count - 1
                count = 1
            else:
                index += 1  # Переходим к следующему слову
                count = 1
            limit = LIMIT

        else:
            # Добавленное слово улучшило показатель совпадения сущности
            limit = temp_entity[2]
            pre_entities = temp_entity[0]
            count += 1

    # Цикл проверки фразы завершен
    if limit >= RESOLVE:
        # Найдена новая сущность
        found_entities.append(pre_entities)
        print("+", found_entities)

    """Если найденная сущность имеет после себя число - это может быть адресом, как Тутаринова 12.
    Тутаринова - это остановка или улица и она является сущностью, но в данном контексте ее 
    нужно рассматривать как адрес. Поэтому удалим из списка сущностей, те, которые могут быть адресами.
    """
    words = remove_similar_words(words, ["номер"])

    print("Ответ:", found_entities)
    return found_entities

# 8 школа дом 146 квартира 55 улица 18 дом автобус 25 едет в 3 школу
# восьмая школа дом сто сорок шесть квартира пятьдесят пять улица восемнадцать дом автобус двадцать пятый едет в третью школу
#
# алиса маршрут номер 256 улица ленина 158 на 3 автобусе дом культуры 11
# алиса маршрут номер двести пятьдесят шесть улица ленина сто пятьдесят восемь на третьем автобусе дом культуры одиннадцать
