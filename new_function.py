"""
Функция принимает:
def get_routers_by_two_busstop(start_stop_name: str, finish_stop_name: str) -> list:

1 --------------------------------
Находим группы, куда входит остановка отправления. 
Берем названия остановок из них. Добавляем туда саму остановку отправления.
То же делаем для остановок прибытия.
Таким образом составляем start_list и finish_list с названиями (не повторяющимися)
остановок отправления и прибытия.

2 --------------------------------
Получаем объекты этих остановок в списках start_objects и finish_objects, 
по скольку остановок обычно по 2 списки удваиваются.

3 --------------------------------
С помощью метода get_bus_by_stop объектов остановок получаем все автобусы 
для каждой остановки отправления и записываем в словарь bus_to_stops:
{
    объект автобуса: список списков [[часть 1],[часть 2]]
}
Части в списках - это списки остановок полученные из записей Order, вычитывать в порядке записи. 
Каждая часть (это несколько записей с order_number от 1 до n) имеет свою запись в Router.
Некоторые автобусы имеют 1 маршрут (в одну сторону), т.е. одну часть.

4 --------------------------------
Запускаем цикл по объектам bus_to_stops
Для каждого автобуса.

5 --------------------------------
Создаем генератор последовательностей (библиотекой python itertools), который из
2 групп остановок отправления и прибытия (start_objects и finish_objects) создаст в цикле 
сочетание всех пар.
Для каждой пары.

6 --------------------------------
Создаем пустой словарь report.
Анализ маршрута.
- если остановки прибытия нет - пропускаем пару
- ставим приоритет 4
- если части 2 и одна из 2 остановок есть в первой части, а другая во второй - приоритет 2
В цикле для частей (приоритет не понижать):
    - если в части есть обе остановки - приоритет 3
    - если отправление стоит раньше чем прибытие (те. в правильном порядке) - приоритет 1

Результаты записываем в словарь report в виде:
{
    остановка отправления: 
    {
        "priority": приоритет, 
        "buses": 
            {
                автобус: 
                {
                    finish: остановка прибытия,
                    "final_stop_start": конечная остановка начала маршрута (откуда), 
                                        той части, где остановка отправления
                    "final_stop_finish": конечная остановка окончания маршрута (куда),
                                        той части, где остановка отправления

                ...
            }
    }
}
Как это работает.
После анализа и получения приоритета находим остановку отправления в словаре или создаем.
если ее приоритет выше чем у новой (например было 2 стало 1), 
то словарь buses пересоздается с новым автобусом и остальными данными, 
если такой-же, то добавляется автобус и остальные данные, иначе не пишется. 

7 --------------------------------
Очищаем report от лишних остановок отправления.
Остановки могут быть только одного приоритета - высшего из имеющихся.
Например если есть остановки с приоритетом 1 то все остановки с приоритетом ниже удаляются,
а если 1 нет, а высший 2, то все ниже него (цифра больше) удаляются и тд.
Если есть только с 4 приоритетом - возвращаем пустой список.

8 --------------------------------
Создаем список timestamp.

1. С помощью этого кода получаем текущий день и время.
    # Текущий день недели (1-7), если дата переопределена в таблице,
    # вернет значение из нее, иначе текущий день недели
    day = Holiday.is_today_holiday()
    day = day if day else datetime.now().isoweekday()
    
    # Определяем текущее время с поправкой на часовой пояс
    time_now = date_now().time()  # конвертируем время в текущий часовой пояс
    
2. Запускаем цикл по report
3. Получаем для каждой остановки отправления список автобусов из buses
4. для каждого автобуса получаем список времени отправления с остановки:
    sch = Schedule.objects.filter(
        bus_stop=start, bus=bus, day=day).order_by('time')
    if len(sch) == 0:  # Если записей нет, переходим к следующему автобусу
        continue
5. проходим по каждой полученной временной метке и добавляем в словарь timestamp,
    если временная метка уже есть, добавляем автобус в ее список:
    {
        время отправления автобуса (временная метка):
            [
                {
                    "bus": автобус,
                    "start": остановка отправления,
                    "finish": остановка прибытия из словаря report для этой остановки и этого автобуса в buses,
                    "modifier": модификатор ответа список с ключами модификаторами,
                    "final_stop_start": конечная остановка маршрута (откуда), 
                                        из словаря report для этой остановки и этого автобуса в buses,
                    "final_stop_finish": конечная остановка маршрута (куда), 
                                        из словаря report для этой остановки и этого автобуса в buses
                },
                ...
            ]

    }

    Что такое модификатор ответа.
    Сообщает формирователю ответа какие есть нюансы в ответе:
    "both" - этот автобус может выходить с 2 разных остановок 
        с одним названием, нужно сообщить название маршрута или конечную остановку, 
        чтобы уточнить о какой идет речь. Т.е. в result есть 2 остановки с одним названием (но разные объекты),
        и в их списках buses есть такой же автобус
    "start_deff" - название остановки отправления отличается от запрошенного, при ответе нужно это подчеркнуть
    "finish_deff" - название остановки прибытия отличается от запрошенного, при ответе нужно это подчеркнуть
    "final_stop_one" - маршрут проходит через конечную остановку (final_stop_start), 
        нужно сообщить через какую, для приоритета 2
    "final_stop_two" - маршрут проходит через 2 конечные остановки (final_stop_finish, final_stop_start), 
        нужно сообщить через какие, для приоритета 3

6 --------------------------------
Сортируем список по времени отправления специальным методом:
    timestamp = dict(sorted(timestamp.items(), key=lambda x: x[0]))
    gen = time_generator(list(timestamp), time_now, 1440)
    timestamp = {time: schedule[time] for time in gen}

7 --------------------------------
Возвращаем словарь timestamp


"""