Этот модуль предоставляет функцию `answer_by_two_busstop` для поиска оптимальных маршрутов между двумя автобусными остановками.

Логика работы функции:

1. РАСШИРЕНИЕ ПОИСКА (ГРУППЫ ОСТАНОВОК)
   - Функция принимает два названия остановок: отправления и прибытия.
   - Чтобы сделать поиск более гибким, она ищет не только по точным названиям, но и по группам остановок (модель StopGroup).
   - Если запрошенная остановка входит в какую-либо группу (например, "Дом культуры" на разных сторонах улицы), в поиск добавляются все остальные остановки из этой группы.
   - В результате создаются два набора названий: `start_list_set` и `finish_list_set`.

2. ПОЛУЧЕНИЕ ОБЪЕКТОВ ИЗ БД
   - На основе собранных названий из базы данных извлекаются реальные объекты остановок (модель BusStop).

3. ПРЕДВАРИТЕЛЬНАЯ ЗАГРУЗКА МАРШРУТОВ
   - Чтобы избежать множества запросов к БД в цикле, программа заранее находит все уникальные автобусы, которые проходят хотя бы через одну из стартовых остановок.
   - Для каждого из этих автобусов загружаются его полные маршруты (т.н. "части", например, путь "туда" и "обратно"). Каждая часть - это упорядоченный по `order_number` список объектов остановок.
   - Данные хранятся в словаре `bus_to_stops` для быстрого доступа.
   С помощью метода get_bus_by_stop объектов остановок получаем все автобусы
    для каждой остановки отправления и записываем в словарь bus_to_stops:
    {
        объект автобуса: список списков [[часть 1],[часть 2]]
    }
    Части в списках - это списки остановок полученные из записей Order, вычитывать в порядке записи.
    Каждая часть (это несколько записей с order_number от 1 до n) имеет свою запись в Router.
    Некоторые автобусы имеют 1 маршрут (в одну сторону), т.е. одну часть.

4. АНАЛИЗ МАРШРУТОВ И ПРИОРИТЕТЫ
   - Это основной и самый сложный блок. Программа перебирает все возможные комбинации: (каждый автобус) x (каждая остановка из группы "старт") x (каждая остановка из группы "финиш").
   - Для каждой комбинации определяется приоритет по следующим правилам (от высшего к низшему):
     - **Приоритет 1 (Идеальный маршрут):** Обе остановки (старт и финиш) находятся в одной части маршрута, и старт идет по порядку раньше финиша.
     - **Приоритет 2 (Маршрут через конечную):** У автобуса есть две части маршрута (туда и обратно), и остановка старта находится в одной части, а финиша — в другой. Этот вариант проверяется только если не был найден Приоритет 1.
     - **Приоритет 3 (Маршрут в обратном направлении):** Обе остановки находятся в одной части, но их порядок обратный (сначала идет финиш, потом старт). Этот вариант имеет самый низкий приоритет.
     - **Приоритет 4 (Невалидный маршрут):** Все остальные случаи.
   - Логика реализована так, чтобы для каждой пары всегда выбирался наивысший из возможных приоритетов (1 > 2 > 3).
    Результаты записываем в словарь report в виде:
    {
        остановка отправления:
        {
            "priority": приоритет,
            "buses":
                {
                    автобус:
                    {
                        finish: остановка прибытия,
                        "final_stop_start": конечная остановка начала маршрута (откуда),
                                            той части, где остановка отправления
                        "final_stop_finish": конечная остановка окончания маршрута (куда),
                                            той части, где остановка отправления
                    },
                    ...
                }
        }
    }

5. ГЛОБАЛЬНАЯ ФИЛЬТРАЦИЯ
   - После анализа всех комбинаций программа смотрит на все найденные маршруты и определяет наивысший приоритет среди них (например, 1).
   - Затем она безжалостно отбрасывает все маршруты, чей приоритет ниже. Если был найден хотя бы один маршрут с Приоритетом 1, все маршруты с Приоритетом 2 и 3 будут удалены.
   - Результат фильтрации помещается в словарь `report`.

6. ПОЛУЧЕНИЕ РАСПИСАНИЯ И МОДИФИКАТОРЫ
   - Для отфильтрованных "лучших" маршрутов программа делает запросы к БД (модель Schedule), чтобы получить конкретное время отправления.
   - На этом же шаге вычисляются **модификаторы** — специальные флаги, которые помогают правильно сформировать текстовый ответ для пользователя:
     - `start_deff`: Устанавливается, название остановки отправления не совпадает с изначально запрошенным.
     - `finish_deff`: То же самое для остановки прибытия.
     - `final_stop_one`: Поясняет пользователю, что маршрут с Приоритетом 2 идет через одну конечную остановку.
     - `final_stop_two`: Поясняет, что маршрут с Приоритетом 3 идет в обратном направлении, и указывает обе конечные этой части маршрута.
     - `both`: Сигнализирует, что один и тот же автобус может отправляться от двух разных остановок с одинаковым названием (например, с разных сторон улицы). Это подсказка пользователю, что маршрут нужно уточнить.
    {
        время отправления автобуса (временная метка):
            [
                {
                    "bus": автобус,
                    "start": остановка отправления,
                    "finish": остановка прибытия из словаря report для этой остановки и этого автобуса в buses,
                    "modifier": модификатор ответа список с ключами модификаторами,
                    "final_stop_start": конечная остановка маршрута (откуда),
                                        из словаря report для этой остановки и этого автобуса в buses,
                    "final_stop_finish": конечная остановка маршрута (куда),
                                        из словаря report для этой остановки и этого автобуса в buses
                },
                ...
            ]

    }
7. ФИНАЛЬНАЯ СОРТИРОВКА
   - Итоговый словарь с рейсами (`timestamp`) сортируется по времени отправления.

8. ВЫВОД
   - Готовый словарь (`Dict`) возвращается как результат работы функции.


Рассматривал вариант показа автобусов идущих через конечную.
Для этого нужно при выборе остановок сначала подготовить список временных меток
с остановок отправления, потом выбрать нужные автобусы и только потом вычислять
приоритеты. Тогда в списке может не оказаться прямых автобусов, а будут просто
ближайшие со всех остановок и такие автобусы могут попасть в список. Как вариант
можно проводить такую выдачу, если нет более подходящих автобусов в ближайший час.
Пока от идеи отказался, чтобы не путать народ.
